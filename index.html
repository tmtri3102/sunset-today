<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A small gift by Tri. Happy Birthday</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåÖ</text></svg>"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link rel="manifest" href="/manifest.json" />
    <link rel="apple-touch-icon" href="/icon-192.png" />
    <style>
      body {
        font-family: "Merriweather", sans-serif;
      }
      .factor-card {
        padding: 1rem;
        border-radius: 0.5rem;
        background-color: #fafafa;
      }
    </style>
  </head>
  <body class="flex items-start min-h-screen p-4 md:p-10 md:justify-center">
    <div
      id="main-container"
      class="w-full max-w-lg mx-auto text-left rounded-2xl p-4 md:p-8 flex flex-col"
    >
      <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-6">
        Ho√†ng h√¥n h√¥m nay th·∫ø n√†o?
      </h1>
      <div class="flex items-center justify-center mb-2">
        <div
          class="relative w-full border-2 border-gray-300 rounded-xl transition-colors"
        >
          <input
            type="text"
            id="city-input"
            placeholder="Nh·∫≠p t√™n th√†nh ph·ªë..."
            class="w-full pl-4 pr-12 py-3 bg-transparent outline-none overflow-hidden"
          />
          <button
            id="get-sunset-btn"
            class="absolute right-0 top-0 h-full flex items-center justify-center px-4 text-gray-400 hover:text-blue-500 transition-colors"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              class="w-6 h-6"
            >
              <path
                fill-rule="evenodd"
                d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z"
                clip-rule="evenodd"
              />
            </svg>
          </button>
        </div>
      </div>

      <div id="results-container">
        <div id="location" class="text-sm text-gray-600 font-medium mb-4"></div>

        <div id="quality-container">
          <div
            id="quality-rating"
            class="text-2xl sm:text-3xl font-extrabold mt-2"
          ></div>
          <div
            id="quality-description"
            class="sm:text-md text-gray-800 mt-1"
          ></div>
        </div>
      </div>
      <div
        id="countdown-container"
        class="hidden inline-flex flex-wrap items-center justify-center"
      >
        <div id="countdown" class="text-sm"></div>
      </div>

      <div id="error" class="text-red-500 font-medium mt-4 min-h-[1.2em]"></div>
      <div id="formula-breakdown" class="text-left hidden"></div>
    </div>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- 1. DOM Element Selection ---
        const cityInput = document.getElementById("city-input");
        const getSunsetBtn = document.getElementById("get-sunset-btn");
        const countdownContainer = document.getElementById(
          "countdown-container"
        );
        const countdownDisplay = document.getElementById("countdown");
        const locationDisplay = document.getElementById("location");
        const errorDisplay = document.getElementById("error");
        const qualityContainer = document.getElementById("quality-container");
        const qualityRatingDisplay = document.getElementById("quality-rating");
        const qualityDescriptionDisplay = document.getElementById(
          "quality-description"
        );
        const formulaBreakdown = document.getElementById("formula-breakdown");

        // --- 2. Global Variable ---
        let countdownInterval;

        // --- 3. API Endpoints ---
        const GEOCodingApi = "https://geocoding-api.open-meteo.com/v1/search";
        const WeatherApi = "https://api.open-meteo.com/v1/forecast";

        // --- 4. Event Listeners ---
        getSunsetBtn.addEventListener("click", findSunset);
        cityInput.addEventListener("keyup", (event) => {
          if (event.key === "Enter") findSunset();
        });

        countdownContainer.addEventListener("click", (event) => {
          if (event.target && event.target.id === "enable-notifications-link") {
            event.preventDefault();
            subscribeUserToPush();
          }
        });

        // --- 5. PWA & Push Notification Functions ---
        async function registerServiceWorker() {
          if ("serviceWorker" in navigator && "PushManager" in window) {
            try {
              await navigator.serviceWorker.register("/service-worker.js");
              console.log("Service Worker registered successfully.");
            } catch (error) {
              console.error("Service Worker registration failed:", error);
            }
          }
        }

        async function subscribeUserToPush() {
          const city = cityInput.value.trim();
          if (!city) {
            alert("B·∫°n ch∆∞a ƒëi·ªÅn t√™n th√†nh ph·ªë trong √¥ t√¨m ki·∫øm.");
            return;
          }
          const permission = await Notification.requestPermission();
          if (permission !== "granted") return;

          try {
            const swRegistration = await navigator.serviceWorker.ready;
            const vapidPublicKey =
              "BJUIBmQ5BCljrwN3xHY2X8yhawY5KV74i9Br9utNnISg29DEo_m9LRP2_bFUWGuGLfzSBAuc0SXooQamB0amrH8";
            const subscription = await swRegistration.pushManager.subscribe({
              userVisibleOnly: true,
              applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
            });
            await fetch("/api/save-subscription", {
              method: "POST",
              body: JSON.stringify({ subscription, city }),
              headers: { "Content-Type": "application/json" },
            });
            alert(`ƒêƒÉng k√Ω nh·∫≠n th√¥ng b√°o cho ${city} th√†nh c√¥ng!`);
          } catch (error) {
            console.error("Failed to subscribe the user: ", error);
            alert("ƒêƒÉng k√Ω nh·∫≠n th√¥ng b√°o th·∫•t b·∫°i.");
          }
        }

        function urlBase64ToUint8Array(base64String) {
          const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
          const base64 = (base64String + padding)
            .replace(/-/g, "+")
            .replace(/_/g, "/");
          const rawData = window.atob(base64);
          const outputArray = new Uint8Array(rawData.length);
          for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
          }
          return outputArray;
        }

        // --- 6. Main Application Logic ---
        async function findSunset() {
          const city = cityInput.value.trim();
          if (!city) {
            errorDisplay.textContent = "Vui l√≤ng nh·∫≠p t√™n th√†nh ph·ªë.";
            return;
          }
          cityInput.blur();
          getSunsetBtn.disabled = true;
          resetUI();
          locationDisplay.textContent = "ƒêang l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt...";
          try {
            const geoData = await getGeoCoordinates(city);
            locationDisplay.textContent = `Kh·∫£ nƒÉng c√≥ ho√†ng h√¥n ƒë·∫πp t·∫°i ${geoData.name}, ${geoData.country} h√¥m nay`;
            const weatherData = await getWeatherData(
              geoData.latitude,
              geoData.longitude
            );
            const now = new Date();
            const todaySunset = new Date(weatherData.daily.sunset[0]);
            const tomorrowSunset = new Date(weatherData.daily.sunset[1]);
            const sunsetTime = now > todaySunset ? tomorrowSunset : todaySunset;
            const sunsetHourIndex = findSunsetHourIndex(
              sunsetTime,
              weatherData.hourly.time
            );
            startCountdown(sunsetTime);
            displaySunsetQuality(
              weatherData.hourly.cloud_cover[sunsetHourIndex],
              weatherData.hourly.relative_humidity_2m[sunsetHourIndex],
              weatherData.hourly.visibility[sunsetHourIndex],
              weatherData.hourly.wind_speed_10m[sunsetHourIndex],
              weatherData.hourly.precipitation_probability[sunsetHourIndex]
            );
          } catch (error) {
            console.error("Error:", error);
            errorDisplay.textContent = error.message;
            locationDisplay.textContent = "";
          } finally {
            getSunsetBtn.disabled = false;
          }
        }

        // --- 7. Helper Functions ---
        function findSunsetHourIndex(sunsetTime, hourlyTimes) {
          const sunsetTimestamp = sunsetTime.getTime();
          for (let i = 0; i < hourlyTimes.length; i++) {
            const hourlyTimestamp = new Date(hourlyTimes[i]).getTime();
            if (hourlyTimestamp >= sunsetTimestamp) {
              if (i > 0) {
                const prevHourlyTimestamp = new Date(
                  hourlyTimes[i - 1]
                ).getTime();
                return Math.abs(sunsetTimestamp - prevHourlyTimestamp) <
                  Math.abs(sunsetTimestamp - hourlyTimestamp)
                  ? i - 1
                  : i;
              }
              return i;
            }
          }
          return hourlyTimes.length - 1;
        }

        async function getGeoCoordinates(city) {
          const response = await fetch(
            `${GEOCodingApi}?name=${encodeURIComponent(city)}&count=1`
          );
          if (!response.ok) throw new Error(`L·ªói m√°y ch·ªß: ${response.status}`);
          const data = await response.json();
          if (!data.results || data.results.length === 0)
            throw new Error(`Kh√¥ng t√¨m th·∫•y "${city}". Vui l√≤ng ki·ªÉm tra l·∫°i.`);
          return data.results[0];
        }

        async function getWeatherData(lat, lon) {
          const apiUrl = `${WeatherApi}?latitude=${lat}&longitude=${lon}&daily=sunset&hourly=cloud_cover,relative_humidity_2m,visibility,wind_speed_10m,precipitation_probability&timezone=auto&forecast_days=2`;
          const response = await fetch(apiUrl);
          if (!response.ok)
            throw new Error(`L·ªói l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt: ${response.status}`);
          return response.json();
        }

        // ** THIS IS THE CORE CALCULATION LOGIC THAT WAS MISSING **
        function calculateScore(value, targetStart, targetEnd) {
          const maxScore = 20;
          if (value >= targetStart && value <= targetEnd) {
            return maxScore;
          }
          const distance =
            value < targetStart ? targetStart - value : value - targetEnd;
          const score = maxScore - (distance * maxScore) / 100;
          return Math.max(0, score);
        }

        function getScoreColor(score) {
          if (score >= 18) return "text-green-500";
          if (score >= 12) return "text-yellow-500";
          return "text-red-500";
        }

        function getFinalScoreColor(finalScore) {
          if (finalScore >= 95) return "text-emerald-600";
          if (finalScore >= 85) return "text-green-500";
          if (finalScore >= 70) return "text-blue-500";
          return "text-gray-500";
        }

        function displaySunsetQuality(
          clouds,
          humidity,
          vis_m,
          wind_kph,
          precipProb
        ) {
          const cloudScore = calculateScore(clouds, 40, 60);
          const humidityScore = calculateScore(humidity, 0, 40);
          const vis_km = vis_m / 1000;
          const visibilityScore = Math.min(20, (vis_km / 20) * 20);
          const windScore = calculateScore(wind_kph, 0, 10);
          const precipScore = calculateScore(precipProb, 0, 5);
          const finalScore = Math.round(
            cloudScore +
              humidityScore +
              visibilityScore +
              windScore +
              precipScore
          );

          let description;
          if (finalScore >= 95)
            description = "Ho√†n h·∫£o! Ch·∫Øc ch·∫Øn b·∫°n kh√¥ng th·ªÉ b·ªè l·ª°.";
          else if (finalScore >= 85)
            description = "R·∫•t cao! C√≥ th·ªÉ c√≥ nhi·ªÅu d·∫£i n·∫Øng ƒë·∫πp.";
          else if (finalScore >= 70)
            description = "Cao. C√≥ th·ªÉ c√≥ v√†i d·∫£i n·∫Øng d·ªãu.";
          else description = "Kh√¥ng cao. Kh√≥ c√≥ ho√†ng h√¥n ƒë·∫πp.";

          qualityContainer.style.display = "block";
          qualityRatingDisplay.textContent = `${finalScore}/100`;
          qualityRatingDisplay.className = `text-3xl font-extrabold mt-2 ${getFinalScoreColor(
            finalScore
          )}`;
          qualityDescriptionDisplay.textContent = description;

          formulaBreakdown.style.display = "block";
          // ** THIS IS THE FULL HTML BREAKDOWN THAT WAS MISSING **
          formulaBreakdown.innerHTML = `
        <div class="grid grid-cols-2 sm:gap-4 gap-2 mt-6">
            <div class="factor-card">
                <div class="flex items-center gap-2"><span class="score-indicator"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg></span><h4 class="text-sm sm:text-base font-semibold">ƒê·ªô che ph·ªß m√¢y</h4></div>
                <p class="text-lg my-2 font-bold text-gray-700">${clouds}%</p>
                <p class="text-xs text-gray-500 italic">L√Ω t∆∞·ªüng: 40-60%</p>
                <p class="mt-2 text-sm font-bold ${getScoreColor(
                  cloudScore
                )}">${cloudScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card">
                <div class="flex items-center gap-2"><span class="score-indicator"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path></svg></span><h4 class="text-sm sm:text-base font-semibold">ƒê·ªô ·∫©m</h4></div>
                <p class="text-lg my-2 font-bold text-gray-700">${humidity}%</p>
                <p class="text-xs text-gray-500 italic">L√Ω t∆∞·ªüng: <40%</p>
                <p class="mt-2 text-sm font-bold ${getScoreColor(
                  humidityScore
                )}">${humidityScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card">
                <div class="flex items-center gap-2"><span class="score-indicator"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg></span><h4 class="text-sm sm:text-base font-semibold">T·∫ßm nh√¨n</h4></div>
                <p class="text-lg my-2 font-bold text-gray-700">${vis_km.toFixed(
                  1
                )} km</p>
                <p class="text-xs text-gray-500 italic">L√Ω t∆∞·ªüng: >20 km</p>
                <p class="mt-2 text-sm font-bold ${getScoreColor(
                  visibilityScore
                )}">${visibilityScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card">
                <div class="flex items-center gap-2"><span class="score-indicator"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path></svg></span><h4 class="text-sm sm:text-base font-semibold">T·ªëc ƒë·ªô gi√≥</h4></div>
                <p class="text-lg my-2 font-bold text-gray-700">${wind_kph.toFixed(
                  1
                )} km/h</p>
                <p class="text-xs text-gray-500 italic">L√Ω t∆∞·ªüng: <10 km/h</p>
                <p class="mt-2 text-sm font-bold ${getScoreColor(
                  windScore
                )}">${windScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card col-span-2">
                <div class="flex items-center gap-2"><span class="score-indicator"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path></svg></span><h4 class="text-sm sm:text-base font-semibold">X√°c su·∫•t m∆∞a</h4></div>
                <p class="text-lg my-2 font-bold text-gray-700">${precipProb}%</p>
                <p class="text-xs text-gray-500 italic">L√Ω t∆∞·ªüng: <5%</p>
                <p class="mt-2 text-sm font-bold ${getScoreColor(
                  precipScore
                )}">${precipScore.toFixed(0)}/20</p>
            </div>
        </div>
        <div class="mt-8 text-gray-700">
          <h3 class="text-base sm:text-lg font-bold text-gray-800 mb-2">C√°ch t√≠nh ƒëi·ªÉm</h3>
          <ul class="text-xs sm:text-sm mt-4 space-y-2">
              <li>T·ªïng ƒëi·ªÉm: 100, d·ª±a tr√™n 5 y·∫øu t·ªë th·ªùi ti·∫øt.</li>
              <li>M·ªói y·∫øu t·ªë t·ªëi ƒëa 20 ƒëi·ªÉm n·∫øu trong ph·∫°m vi l√Ω t∆∞·ªüng (PVLT), l·ªách c√†ng nhi·ªÅu ƒëi·ªÉm c√†ng gi·∫£m.</li>
          </ul>
        </div>
      `;
        }

        function startCountdown(targetDate) {
          countdownContainer.style.display = "block";
          if (countdownInterval) clearInterval(countdownInterval);
          const update = () => {
            const now = new Date().getTime();
            const distance = targetDate - now;
            if (distance < 0) {
              clearInterval(countdownInterval);
              countdownDisplay.textContent = "Ho√†ng h√¥n ƒë√£ qua r·ªìi nha.";
              return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor(
              (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)
            );
            const minutes = Math.floor(
              (distance % (1000 * 60 * 60)) / (1000 * 60)
            );
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            let str = `c√≤n <span class="font-bold text-orange-600">${hours}h ${minutes}m ${seconds}s</span> n·ªØa l√† ho√†ng h√¥n<br/><a href="#" id="enable-notifications-link" class="text-blue-600 hover:underline">(nh·∫≠n th√¥ng b√°o)</a>`;
            if (days > 0) str = `${days}d ` + str;
            countdownDisplay.innerHTML = str;
          };
          update();
          countdownInterval = setInterval(update, 1000);
        }

        function resetUI() {
          errorDisplay.textContent = "";
          locationDisplay.textContent = "";
          countdownContainer.style.display = "none";
          qualityContainer.style.display = "none";
          formulaBreakdown.style.display = "none";
          if (countdownInterval) clearInterval(countdownInterval);
        }

        // Initial call to register the service worker when the page is ready.
        registerServiceWorker();
      });
    </script>
  </body>
</html>
