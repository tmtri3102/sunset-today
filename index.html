<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sunset Quality Predictor</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåÖ</text></svg>"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Merriweather", sans-serif;
      }
      .factor-card {
        padding: 1rem;
        border-radius: 0.5rem;
        background-color: #fafafa;
      }
    </style>
  </head>
  <body
    class="flex items-start min-h-screen p-4 md:p-10 md:justify-center bg-gray-50"
  >
    <div
      id="main-container"
      class="w-full max-w-lg mx-auto text-left rounded-2xl p-4 md:p-8 flex flex-col"
    >
      <h1 class="text-2xl sm:text-3xl font-bold text-gray-800 mb-6">
        Ho√†ng h√¥n h√¥m nay th·∫ø n√†o?
      </h1>
      <div class="flex items-center justify-center mb-2">
        <div
          class="relative w-full border-2 border-gray-300 rounded-xl transition-colors"
        >
          <input
            type="text"
            id="city-input"
            placeholder="Nh·∫≠p t√™n th√†nh ph·ªë..."
            class="w-full pl-4 pr-12 py-3 bg-transparent outline-none"
          />
          <button
            id="get-sunset-btn"
            class="absolute right-0 top-0 h-full flex items-center justify-center px-4 text-gray-400 hover:text-blue-500 transition-colors"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="currentColor"
              class="w-6 h-6"
            >
              <path
                fill-rule="evenodd"
                d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z"
                clip-rule="evenodd"
              />
            </svg>
          </button>
        </div>
      </div>

      <div id="results-container">
        <div id="location" class="text-sm text-gray-600 font-medium mb-4"></div>
        <div id="quality-container" style="display: none">
          <div
            id="quality-rating"
            class="text-2xl sm:text-3xl font-extrabold mt-2"
          ></div>
          <div
            id="quality-description"
            class="sm:text-md text-gray-800 mt-1"
          ></div>
        </div>
      </div>
      <div id="countdown-container" class="hidden">
        <div id="countdown" class="text-sm"></div>
      </div>

      <div id="error" class="text-red-500 font-medium mt-4 min-h-[1.2em]"></div>
      <div id="formula-breakdown" class="text-left hidden"></div>
    </div>
    <script>
      const GEOCodingApi = "https://geocoding-api.open-meteo.com/v1/search";
      const WeatherApi = "https://api.open-meteo.com/v1/forecast";

      const cityInput = document.getElementById("city-input");
      const getSunsetBtn = document.getElementById("get-sunset-btn");
      const countdownDisplay = document.getElementById("countdown");
      const locationDisplay = document.getElementById("location");
      const errorDisplay = document.getElementById("error");
      const countdownContainer = document.getElementById("countdown-container");
      const qualityContainer = document.getElementById("quality-container");
      const qualityRatingDisplay = document.getElementById("quality-rating");
      const qualityDescriptionDisplay = document.getElementById(
        "quality-description"
      );
      const formulaBreakdown = document.getElementById("formula-breakdown");

      let countdownInterval;

      getSunsetBtn.addEventListener("click", findSunset);
      cityInput.addEventListener("keyup", (event) => {
        if (event.key === "Enter") findSunset();
      });

      async function findSunset() {
        const city = cityInput.value.trim();
        if (!city) {
          errorDisplay.textContent = "Vui l√≤ng nh·∫≠p t√™n th√†nh ph·ªë.";
          return;
        }

        cityInput.blur();
        getSunsetBtn.disabled = true;

        resetUI();
        locationDisplay.textContent = "ƒêang l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt...";

        try {
          const geoData = await getGeoCoordinates(city);
          const { latitude, longitude, name, country } = geoData;
          locationDisplay.textContent = `Kh·∫£ nƒÉng c√≥ ho√†ng h√¥n ƒë·∫πp t·∫°i ${name}, ${country} h√¥m nay`;

          const weatherData = await getWeatherData(latitude, longitude);

          const now = new Date();
          let sunsetTime;
          const todaySunset = new Date(weatherData.daily.sunset[0]);
          const tomorrowSunset = new Date(weatherData.daily.sunset[1]);

          sunsetTime = now > todaySunset ? tomorrowSunset : todaySunset;

          let sunsetHourIndex = findSunsetHourIndex(
            sunsetTime,
            weatherData.hourly.time
          );
          startCountdown(sunsetTime);

          const cloudCover = weatherData.hourly.cloud_cover[sunsetHourIndex];
          const humidity =
            weatherData.hourly.relative_humidity_2m[sunsetHourIndex];
          const visibility = weatherData.hourly.visibility[sunsetHourIndex];
          const windSpeed = weatherData.hourly.wind_speed_10m[sunsetHourIndex];
          const precipProb =
            weatherData.hourly.precipitation_probability[sunsetHourIndex];

          displaySunsetQuality(
            cloudCover,
            humidity,
            visibility,
            windSpeed,
            precipProb
          );
        } catch (error) {
          console.error("Error:", error);
          errorDisplay.textContent = error.message;
          locationDisplay.textContent = "";
        } finally {
          getSunsetBtn.disabled = false;
        }
      }

      function findSunsetHourIndex(sunsetTime, hourlyTimes) {
        const sunsetTimestamp = sunsetTime.getTime();
        for (let i = 0; i < hourlyTimes.length; i++) {
          const hourlyTimestamp = new Date(hourlyTimes[i]).getTime();
          if (hourlyTimestamp >= sunsetTimestamp) {
            if (i > 0) {
              const prevHourlyTimestamp = new Date(
                hourlyTimes[i - 1]
              ).getTime();
              return Math.abs(sunsetTimestamp - prevHourlyTimestamp) <
                Math.abs(sunsetTimestamp - hourlyTimestamp)
                ? i - 1
                : i;
            }
            return i;
          }
        }
        return hourlyTimes.length - 1;
      }

      async function getGeoCoordinates(city) {
        const response = await fetch(
          `${GEOCodingApi}?name=${encodeURIComponent(city)}&count=1`
        );
        if (!response.ok) throw new Error(`L·ªói m√°y ch·ªß: ${response.status}`);
        const data = await response.json();
        if (!data.results || data.results.length === 0)
          throw new Error(`Kh√¥ng t√¨m th·∫•y "${city}". Vui l√≤ng ki·ªÉm tra l·∫°i.`);
        return data.results[0];
      }

      async function getWeatherData(lat, lon) {
        const apiUrl = `${WeatherApi}?latitude=${lat}&longitude=${lon}&daily=sunset&hourly=cloud_cover,relative_humidity_2m,visibility,wind_speed_10m,precipitation_probability&timezone=auto&forecast_days=2`;
        const response = await fetch(apiUrl);
        if (!response.ok)
          throw new Error(`L·ªói l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt: ${response.status}`);
        return response.json();
      }

      function calculateScore(value, targetStart, targetEnd) {
        const maxScore = 20;
        if (value >= targetStart && value <= targetEnd) return maxScore;
        const distance =
          value < targetStart ? targetStart - value : value - targetEnd;
        return Math.max(0, maxScore - (distance * maxScore) / 100);
      }

      function getScoreColor(score) {
        if (score >= 18) return "text-green-500";
        if (score >= 12) return "text-yellow-500";
        return "text-red-500";
      }

      function getFinalScoreColor(finalScore) {
        if (finalScore >= 95) return "text-emerald-600";
        if (finalScore >= 85) return "text-green-500";
        if (finalScore >= 70) return "text-blue-500";
        return "text-gray-500";
      }

      function displaySunsetQuality(
        clouds,
        humidity,
        vis_m,
        wind_kph,
        precipProb
      ) {
        const cloudScore = calculateScore(clouds, 40, 60);
        const humidityScore = calculateScore(humidity, 0, 40);
        const visibilityScore = Math.min(20, (vis_m / 1000 / 20) * 20);
        const windScore = calculateScore(wind_kph, 0, 10);
        const precipScore = calculateScore(precipProb, 0, 5);
        const finalScore = Math.round(
          cloudScore + humidityScore + visibilityScore + windScore + precipScore
        );

        let rating, description;
        if (finalScore >= 95) {
          description = "Ho√†n h·∫£o! Ch·∫Øc ch·∫Øn b·∫°n kh√¥ng th·ªÉ b·ªè l·ª°.";
        } else if (finalScore >= 85) {
          description = "R·∫•t cao! C√≥ th·ªÉ c√≥ nhi·ªÅu d·∫£i n·∫Øng ƒë·∫πp.";
        } else if (finalScore >= 70) {
          description = "Cao. C√≥ th·ªÉ c√≥ v√†i d·∫£i n·∫Øng d·ªãu.";
        } else {
          description = "Kh√¥ng cao. Kh√≥ c√≥ ho√†ng h√¥n ƒë·∫πp.";
        }

        qualityContainer.style.display = "block";
        qualityRatingDisplay.textContent = `${finalScore}/100`;
        qualityRatingDisplay.className = `text-3xl font-extrabold mt-2 ${getFinalScoreColor(
          finalScore
        )}`;
        qualityDescriptionDisplay.textContent = description;

        formulaBreakdown.style.display = "block";
        formulaBreakdown.innerHTML = `
          <div class="grid grid-cols-2 sm:gap-4 gap-2 mt-4">
            <div class="factor-card">
                <h4 class="text-sm font-semibold">ƒê·ªô che ph·ªß m√¢y</h4>
                <p class="text-lg font-bold text-gray-700">${clouds}%</p>
                <p class="mt-1 font-bold ${getScoreColor(
                  cloudScore
                )}">${cloudScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card">
                <h4 class="text-sm font-semibold">ƒê·ªô ·∫©m</h4>
                <p class="text-lg font-bold text-gray-700">${humidity}%</p>
                <p class="mt-1 font-bold ${getScoreColor(
                  humidityScore
                )}">${humidityScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card">
                <h4 class="text-sm font-semibold">T·∫ßm nh√¨n</h4>
                <p class="text-lg font-bold text-gray-700">${(
                  vis_m / 1000
                ).toFixed(1)} km</p>
                <p class="mt-1 font-bold ${getScoreColor(
                  visibilityScore
                )}">${visibilityScore.toFixed(0)}/20</p>
            </div>
            <div class="factor-card">
                <h4 class="text-sm font-semibold">T·ªëc ƒë·ªô gi√≥</h4>
                <p class="text-lg font-bold text-gray-700">${wind_kph.toFixed(
                  1
                )} km/h</p>
                <p class="mt-1 font-bold ${getScoreColor(
                  windScore
                )}">${windScore.toFixed(0)}/20</p>
            </div>
          </div>
          <div id="subscribe-container" class="mt-8 border-t pt-6">
            <h3 class="text-lg font-bold text-gray-700 mb-2">Nh·∫≠n th√¥ng b√°o khi s·∫Øp c√≥ ho√†ng h√¥n ƒë·∫πp</h3>
            <div class="flex flex-col sm:flex-row gap-2">
              <input type="text" id="subscribe-city" placeholder="T√™n th√†nh ph·ªë" class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
              <input type="email" id="subscribe-email" placeholder="Email" class="w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            <button id="subscribe-btn" class="mt-3 w-full bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors">
              ƒêƒÉng k√Ω
            </button>
            <p id="subscribe-message" class="text-sm mt-2 min-h-[1.2em]"></p>
          </div>`;

        // Re-bind the event listener every time new HTML is created
        document
          .getElementById("subscribe-btn")
          .addEventListener("click", handleSubscription);
      }

      function startCountdown(targetDate) {
        countdownContainer.style.display = "block";
        if (countdownInterval) clearInterval(countdownInterval);

        const update = () => {
          const distance = targetDate - new Date();
          if (distance < 0) {
            clearInterval(countdownInterval);
            countdownDisplay.textContent = "Ho√†ng h√¥n ƒë√£ qua r·ªìi nha.";
            return;
          }
          const hours = Math.floor(
            (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)
          );
          const minutes = Math.floor(
            (distance % (1000 * 60 * 60)) / (1000 * 60)
          );
          const seconds = Math.floor((distance % (1000 * 60)) / 1000);
          countdownDisplay.innerHTML = `c√≤n <span class="font-bold text-orange-600">${hours}h ${minutes}m ${seconds}s</span> n·ªØa l√† ho√†ng h√¥n`;
        };
        update();
        countdownInterval = setInterval(update, 1000);
      }

      async function handleSubscription() {
        const subscribeCityInput = document.getElementById("subscribe-city");
        const subscribeEmailInput = document.getElementById("subscribe-email");
        const subscribeMessage = document.getElementById("subscribe-message");

        const city = subscribeCityInput.value.trim();
        const email = subscribeEmailInput.value.trim();

        if (!city || !email) {
          subscribeMessage.textContent = "Vui l√≤ng nh·∫≠p c·∫£ th√†nh ph·ªë v√† email.";
          subscribeMessage.style.color = "red";
          return;
        }

        subscribeMessage.textContent = "ƒêang ƒëƒÉng k√Ω...";
        subscribeMessage.style.color = "gray";

        try {
          const response = await fetch("/api/subscribe", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ city, email }),
          });
          const result = await response.json();
          if (!response.ok) throw new Error(result.message);

          subscribeMessage.textContent = result.message;
          subscribeMessage.style.color = "green";
          subscribeCityInput.value = "";
          subscribeEmailInput.value = "";
        } catch (error) {
          subscribeMessage.textContent = `L·ªói: ${error.message}`;
          subscribeMessage.style.color = "red";
        }
      }

      function resetUI() {
        errorDisplay.textContent = "";
        locationDisplay.textContent = "";
        countdownContainer.style.display = "none";
        qualityContainer.style.display = "none";
        formulaBreakdown.style.display = "none";
        if (countdownInterval) clearInterval(countdownInterval);
      }
    </script>
  </body>
</html>
